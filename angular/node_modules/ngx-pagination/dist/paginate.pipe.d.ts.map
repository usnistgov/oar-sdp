{"version":3,"file":"paginate.pipe.d.ts","sources":["paginate.pipe.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { PaginationService } from \"./pagination.service\";\r\nexport declare class PaginatePipe {\r\n    private service;\r\n    private state;\r\n    constructor(service: PaginationService);\r\n    transform(collection: any[] | ReadonlyArray<any>, args: any): any;\r\n    /**\r\n     * Create an PaginationInstance object, using defaults for any optional properties not supplied.\r\n     */\r\n    private createInstance(collection, args);\r\n    /**\r\n     * Ensure the argument passed to the filter contains the required properties.\r\n     */\r\n    private checkConfig(config);\r\n    /**\r\n     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced\r\n     * array for a given id. This means that the next time the pipe is run on this collection & id, we just\r\n     * need to check that the collection, start and end points are all identical, and if so, return the\r\n     * last sliced array.\r\n     */\r\n    private saveState(id, collection, slice, start, end);\r\n    /**\r\n     * For a given id, returns true if the collection, size, start and end values are identical.\r\n     */\r\n    private stateIsIdentical(id, collection, start, end);\r\n}\r\n"]}