{"version":3,"file":"testing.d.ts","sources":["testing.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v12.2.15\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ChangeDetectorRef } from '@angular/core';\r\nimport { Compiler } from '@angular/core';\r\nimport { CompilerOptions } from '@angular/core';\r\nimport { Component } from '@angular/core';\r\nimport { ComponentFactory } from '@angular/core';\r\nimport { ComponentRef } from '@angular/core';\r\nimport { DebugElement } from '@angular/core';\r\nimport { Directive } from '@angular/core';\r\nimport { ElementRef } from '@angular/core';\r\nimport { InjectFlags } from '@angular/core';\r\nimport { InjectionToken } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { NgModule } from '@angular/core';\r\nimport { NgZone } from '@angular/core';\r\nimport { Pipe } from '@angular/core';\r\nimport { PlatformRef } from '@angular/core';\r\nimport { ProviderToken } from '@angular/core';\r\nimport { SchemaMetadata } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\n\r\n/**\r\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\r\n * investigation.\r\n *\r\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\r\n *\r\n * @codeGenApi\r\n */\r\nexport declare const __core_private_testing_placeholder__ = \"\";\r\n\r\n/**\r\n * @deprecated use `waitForAsync()`, (expected removal in v12)\r\n * @see {@link waitForAsync}\r\n * @publicApi\r\n * */\r\nexport declare function async(fn: Function): (done: any) => any;\r\n\r\n/**\r\n * Fixture for debugging and testing a component.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ComponentFixture<T> {\r\n    componentRef: ComponentRef<T>;\r\n    ngZone: NgZone | null;\r\n    private _autoDetect;\r\n    /**\r\n     * The DebugElement associated with the root element of this component.\r\n     */\r\n    debugElement: DebugElement;\r\n    /**\r\n     * The instance of the root component class.\r\n     */\r\n    componentInstance: T;\r\n    /**\r\n     * The native element at the root of the component.\r\n     */\r\n    nativeElement: any;\r\n    /**\r\n     * The ElementRef for the element at the root of the component.\r\n     */\r\n    elementRef: ElementRef;\r\n    /**\r\n     * The ChangeDetectorRef for the component\r\n     */\r\n    changeDetectorRef: ChangeDetectorRef;\r\n    private _renderer;\r\n    private _isStable;\r\n    private _isDestroyed;\r\n    private _resolve;\r\n    private _promise;\r\n    private _onUnstableSubscription;\r\n    private _onStableSubscription;\r\n    private _onMicrotaskEmptySubscription;\r\n    private _onErrorSubscription;\r\n    constructor(componentRef: ComponentRef<T>, ngZone: NgZone | null, _autoDetect: boolean);\r\n    private _tick;\r\n    /**\r\n     * Trigger a change detection cycle for the component.\r\n     */\r\n    detectChanges(checkNoChanges?: boolean): void;\r\n    /**\r\n     * Do a change detection run to make sure there were no changes.\r\n     */\r\n    checkNoChanges(): void;\r\n    /**\r\n     * Set whether the fixture should autodetect changes.\r\n     *\r\n     * Also runs detectChanges once so that any existing change is detected.\r\n     */\r\n    autoDetectChanges(autoDetect?: boolean): void;\r\n    /**\r\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\r\n     * yet.\r\n     */\r\n    isStable(): boolean;\r\n    /**\r\n     * Get a promise that resolves when the fixture is stable.\r\n     *\r\n     * This can be used to resume testing after events have triggered asynchronous activity or\r\n     * asynchronous change detection.\r\n     */\r\n    whenStable(): Promise<any>;\r\n    private _getRenderer;\r\n    /**\r\n     * Get a promise that resolves when the ui state is stable following animations.\r\n     */\r\n    whenRenderingDone(): Promise<any>;\r\n    /**\r\n     * Trigger component destruction.\r\n     */\r\n    destroy(): void;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const ComponentFixtureAutoDetect: InjectionToken<boolean[]>;\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const ComponentFixtureNoNgZone: InjectionToken<boolean[]>;\r\n\r\n/**\r\n * Discard all remaining periodic tasks.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function discardPeriodicTasks(): void;\r\n\r\n/**\r\n * Wraps a function to be executed in the `fakeAsync` zone:\r\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\r\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\r\n *\r\n * If there are any pending timers at the end of the function, an exception is thrown.\r\n *\r\n * Can be used to wrap `inject()` calls.\r\n *\r\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n *\r\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\r\n * Any arguments passed when calling this returned function will be passed through to the `fn`\r\n * function in the parameters when it is called.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function fakeAsync(fn: Function): (...args: any[]) => any;\r\n\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\r\n * draining the macrotask queue until it is empty.\r\n *\r\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\r\n *     throwing an error.\r\n * @returns The simulated time elapsed, in milliseconds.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function flush(maxTurns?: number): number;\r\n\r\n/**\r\n * Flush any pending microtasks.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function flushMicrotasks(): void;\r\n\r\n/**\r\n * Returns a singleton of the applicable `TestBed`.\r\n *\r\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const getTestBed: () => TestBed;\r\n\r\n/**\r\n * Allows injecting dependencies in `beforeEach()` and `it()`.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\r\n *   // some code that uses `dep` and `object`\r\n *   // ...\r\n * }));\r\n *\r\n * it('...', inject([AClass], (object) => {\r\n *   object.doSomething();\r\n *   expect(...);\r\n * })\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare function inject(tokens: any[], fn: Function): () => any;\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare class InjectSetupWrapper {\r\n    private _moduleDef;\r\n    constructor(_moduleDef: () => TestModuleMetadata);\r\n    private _addModule;\r\n    inject(tokens: any[], fn: Function): () => any;\r\n}\r\n\r\n\r\n/**\r\n * Type used for modifications to metadata\r\n *\r\n * @publicApi\r\n */\r\nexport declare type MetadataOverride<T> = {\r\n    add?: Partial<T>;\r\n    remove?: Partial<T>;\r\n    set?: Partial<T>;\r\n};\r\n\r\n/**\r\n * Object used to configure the test module teardown behavior in `TestBed`.\r\n * @publicApi\r\n */\r\nexport declare interface ModuleTeardownOptions {\r\n    /** Whether the test module should be destroyed after every test. */\r\n    destroyAfterEach: boolean;\r\n    /** Whether errors during test module destruction should be re-thrown. Defaults to `true`. */\r\n    rethrowErrors?: boolean;\r\n}\r\n\r\n/**\r\n * Clears out the shared fake async zone for a test.\r\n * To be called in a global `beforeEach`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function resetFakeAsyncZone(): void;\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare interface TestBed {\r\n    platform: PlatformRef;\r\n    ngModule: Type<any> | Type<any>[];\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     */\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, options?: TestEnvironmentOptions): void;\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     */\r\n    resetTestEnvironment(): void;\r\n    resetTestingModule(): void;\r\n    configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): void;\r\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\r\n    compileComponents(): Promise<any>;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get(token: any, notFoundValue?: any): any;\r\n    execute(tokens: any[], fn: Function, context?: any): any;\r\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\r\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\r\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\r\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     */\r\n    overrideProvider(token: any, provider: {\r\n        useFactory: Function;\r\n        deps: any[];\r\n    }): void;\r\n    overrideProvider(token: any, provider: {\r\n        useValue: any;\r\n    }): void;\r\n    overrideProvider(token: any, provider: {\r\n        useFactory?: Function;\r\n        useValue?: any;\r\n        deps?: any[];\r\n    }): void;\r\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\r\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\r\n}\r\n\r\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const TestBed: TestBedStatic;\r\n\r\n/**\r\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface TestBedStatic {\r\n    new (...args: any[]): TestBed;\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, options?: {\r\n        teardown?: ModuleTeardownOptions;\r\n    }): TestBed;\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     */\r\n    resetTestEnvironment(): void;\r\n    resetTestingModule(): TestBedStatic;\r\n    /**\r\n     * Allows overriding default compiler providers and settings\r\n     * which are defined in test_injector.js\r\n     */\r\n    configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): TestBedStatic;\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     */\r\n    configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     */\r\n    compileComponents(): Promise<any>;\r\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\r\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\r\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\r\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\r\n    overrideTemplate(component: Type<any>, template: string): TestBedStatic;\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    overrideProvider(token: any, provider: {\r\n        useFactory: Function;\r\n        deps: any[];\r\n    }): TestBedStatic;\r\n    overrideProvider(token: any, provider: {\r\n        useValue: any;\r\n    }): TestBedStatic;\r\n    overrideProvider(token: any, provider: {\r\n        useFactory?: Function;\r\n        useValue?: any;\r\n        deps?: any[];\r\n    }): TestBedStatic;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get(token: any, notFoundValue?: any): any;\r\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\r\n}\r\n\r\n/**\r\n * An abstract class for inserting the root test component element in a platform independent way.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class TestComponentRenderer {\r\n    insertRootElement(rootElementId: string): void;\r\n    removeAllRootElements?(): void;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare interface TestEnvironmentOptions {\r\n    aotSummaries?: () => any[];\r\n    teardown?: ModuleTeardownOptions;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare type TestModuleMetadata = {\r\n    providers?: any[];\r\n    declarations?: any[];\r\n    imports?: any[];\r\n    schemas?: Array<SchemaMetadata | any[]>;\r\n    aotSummaries?: () => any[];\r\n    teardown?: ModuleTeardownOptions;\r\n};\r\n\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\r\n *\r\n * The microtasks queue is drained at the very start of this function and after any timer callback\r\n * has been executed.\r\n *\r\n * @param millis The number of milliseconds to advance the virtual timer.\r\n * @param tickOptions The options to pass to the `tick()` function.\r\n *\r\n * @usageNotes\r\n *\r\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\r\n * which determines whether or not to invoke new macroTasks.\r\n *\r\n * If you provide a `tickOptions` object, but do not specify a\r\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\r\n * then `processNewMacroTasksSynchronously` defaults to true.\r\n *\r\n * If you omit the `tickOptions` parameter (`tick(100))`), then\r\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * The following example includes a nested timeout (new macroTask), and\r\n * the `tickOptions` parameter is allowed to default. In this case,\r\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\r\n * function is executed on each tick.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick();\r\n *   expect(nestedTimeoutInvoked).toBe(true);\r\n * }));\r\n * ```\r\n *\r\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\r\n * set to false, so the nested timeout function is not invoked.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick(0, {processNewMacroTasksSynchronously: false});\r\n *   expect(nestedTimeoutInvoked).toBe(false);\r\n * }));\r\n * ```\r\n *\r\n *\r\n * @publicApi\r\n */\r\nexport declare function tick(millis?: number, tickOptions?: {\r\n    processNewMacroTasksSynchronously: boolean;\r\n}): void;\r\n\r\n\r\n/**\r\n * Wraps a test function in an asynchronous test zone. The test will automatically\r\n * complete when all asynchronous calls within this zone are done. Can be used\r\n * to wrap an {@link inject} call.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * it('...', waitForAsync(inject([AClass], (object) => {\r\n *   object.doSomething.then(() => {\r\n *     expect(...);\r\n *   })\r\n * });\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare function waitForAsync(fn: Function): (done: any) => any;\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\r\n\r\nexport declare function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\r\n\r\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n */\r\nexport declare class ɵangular_packages_core_testing_testing_a implements TestBed {\r\n    /**\r\n     * Teardown options that have been configured at the environment level.\r\n     * Used as a fallback if no instance-level options have been provided.\r\n     */\r\n    private static _environmentTeardownOptions;\r\n    /**\r\n     * Teardown options that have been configured at the `TestBed` instance level.\r\n     * These options take precedence over the environemnt-level ones.\r\n     */\r\n    private _instanceTeardownOptions;\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     */\r\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, summariesOrOptions?: TestEnvironmentOptions | (() => any[])): ɵangular_packages_core_testing_testing_a;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     */\r\n    static resetTestEnvironment(): void;\r\n    static resetTestingModule(): TestBedStatic;\r\n    /**\r\n     * Allows overriding default compiler providers and settings\r\n     * which are defined in test_injector.js\r\n     */\r\n    static configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): TestBedStatic;\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     */\r\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     */\r\n    static compileComponents(): Promise<any>;\r\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\r\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\r\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\r\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\r\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    static overrideProvider(token: any, provider: {\r\n        useFactory: Function;\r\n        deps: any[];\r\n    }): TestBedStatic;\r\n    static overrideProvider(token: any, provider: {\r\n        useValue: any;\r\n    }): TestBedStatic;\r\n    static inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    static inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    static get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /**\r\n     * @deprecated from v9.0.0 use TestBed.inject\r\n     * @suppress {duplicate}\r\n     */\r\n    static get(token: any, notFoundValue?: any): any;\r\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\r\n    static shouldTearDownTestingModule(): boolean;\r\n    static tearDownTestingModule(): void;\r\n    private _instantiated;\r\n    private _compiler;\r\n    private _moduleRef;\r\n    private _moduleFactory;\r\n    private _pendingModuleFactory;\r\n    private _compilerOptions;\r\n    private _moduleOverrides;\r\n    private _componentOverrides;\r\n    private _directiveOverrides;\r\n    private _pipeOverrides;\r\n    private _providers;\r\n    private _declarations;\r\n    private _imports;\r\n    private _schemas;\r\n    private _activeFixtures;\r\n    private _testEnvAotSummaries;\r\n    private _aotSummaries;\r\n    private _templateOverrides;\r\n    private _isRoot;\r\n    private _rootProviderOverrides;\r\n    platform: PlatformRef;\r\n    ngModule: Type<any> | Type<any>[];\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     */\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, summariesOrOptions?: TestEnvironmentOptions | (() => any[])): void;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     */\r\n    resetTestEnvironment(): void;\r\n    resetTestingModule(): void;\r\n    configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): void;\r\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\r\n    compileComponents(): Promise<any>;\r\n    private _initIfNeeded;\r\n    private _createCompilerAndModule;\r\n    private _assertNotInstantiated;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get(token: any, notFoundValue?: any): any;\r\n    execute(tokens: any[], fn: Function, context?: any): any;\r\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\r\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\r\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\r\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     */\r\n    overrideProvider(token: any, provider: {\r\n        useFactory: Function;\r\n        deps: any[];\r\n    }): void;\r\n    overrideProvider(token: any, provider: {\r\n        useValue: any;\r\n    }): void;\r\n    private overrideProviderImpl;\r\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\r\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\r\n    private destroyActiveFixtures;\r\n    private shouldRethrowTeardownErrors;\r\n    shouldTearDownTestingModule(): boolean;\r\n    tearDownTestingModule(): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\r\n * according to the compiler used.\r\n */\r\nexport declare class ɵangular_packages_core_testing_testing_b implements TestBed {\r\n    /**\r\n     * Teardown options that have been configured at the environment level.\r\n     * Used as a fallback if no instance-level options have been provided.\r\n     */\r\n    private static _environmentTeardownOptions;\r\n    /**\r\n     * Teardown options that have been configured at the `TestBed` instance level.\r\n     * These options take precedence over the environemnt-level ones.\r\n     */\r\n    private _instanceTeardownOptions;\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     *\r\n     * @publicApi\r\n     */\r\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, summariesOrOptions?: TestEnvironmentOptions | (() => any[])): TestBed;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * @publicApi\r\n     */\r\n    static resetTestEnvironment(): void;\r\n    static configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): TestBedStatic;\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     */\r\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     */\r\n    static compileComponents(): Promise<any>;\r\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\r\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\r\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\r\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\r\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\r\n    static overrideProvider(token: any, provider: {\r\n        useFactory: Function;\r\n        deps: any[];\r\n    }): TestBedStatic;\r\n    static overrideProvider(token: any, provider: {\r\n        useValue: any;\r\n    }): TestBedStatic;\r\n    static inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    static inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    static get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    static get(token: any, notFoundValue?: any): any;\r\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\r\n    static resetTestingModule(): TestBedStatic;\r\n    static shouldTearDownTestingModule(): boolean;\r\n    static tearDownTestingModule(): void;\r\n    platform: PlatformRef;\r\n    ngModule: Type<any> | Type<any>[];\r\n    private _compiler;\r\n    private _testModuleRef;\r\n    private _activeFixtures;\r\n    private _globalCompilationChecked;\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     *\r\n     * @publicApi\r\n     */\r\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, summariesOrOptions?: {\r\n        teardown?: ModuleTeardownOptions;\r\n    } | (() => any[])): void;\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * @publicApi\r\n     */\r\n    resetTestEnvironment(): void;\r\n    resetTestingModule(): void;\r\n    configureCompiler(config: {\r\n        providers?: any[];\r\n        useJit?: boolean;\r\n    }): void;\r\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\r\n    compileComponents(): Promise<any>;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\r\n    inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get(token: any, notFoundValue?: any): any;\r\n    execute(tokens: any[], fn: Function, context?: any): any;\r\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\r\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\r\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\r\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\r\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     */\r\n    overrideProvider(token: any, provider: {\r\n        useFactory?: Function;\r\n        useValue?: any;\r\n        deps?: any[];\r\n    }): void;\r\n    createComponent<T>(type: Type<T>): ComponentFixture<T>;\r\n    private assertNotInstantiated;\r\n    /**\r\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\r\n     *\r\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\r\n     * in-progress module compilation. This creates a potential hazard - the very first time the\r\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\r\n     * compilations of modules declared in global scope. These compilations should be finished.\r\n     *\r\n     * To ensure that globally declared modules have their components scoped properly, this function\r\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\r\n     * to any other operations, the scoping queue is flushed.\r\n     */\r\n    private checkGlobalCompilationFinished;\r\n    private destroyActiveFixtures;\r\n    private shouldRethrowTeardownErrors;\r\n    shouldTearDownTestingModule(): boolean;\r\n    tearDownTestingModule(): void;\r\n}\r\n\r\nexport declare function ɵangular_packages_core_testing_testing_c(): ɵangular_packages_core_testing_testing_b;\r\n\r\nexport declare class ɵMetadataOverrider {\r\n    private _references;\r\n    /**\r\n     * Creates a new instance for the given metadata class\r\n     * based on an old instance and overrides.\r\n     */\r\n    overrideMetadata<C extends T, T>(metadataClass: {\r\n        new (options: T): C;\r\n    }, oldMetadata: C, override: MetadataOverride<T>): C;\r\n}\r\n\r\n/**\r\n * Special interface to the compiler only used by testing\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ɵTestingCompiler extends Compiler {\r\n    get injector(): Injector;\r\n    overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void;\r\n    overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void;\r\n    overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void;\r\n    overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void;\r\n    /**\r\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\r\n     * so that it can use the code generated by AOT.\r\n     */\r\n    loadAotSummaries(summaries: () => any[]): void;\r\n    /**\r\n     * Gets the component factory for the given component.\r\n     * This assumes that the component has been compiled before calling this call using\r\n     * `compileModuleAndAllComponents*`.\r\n     */\r\n    getComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\r\n    /**\r\n     * Returns the component type that is stored in the given error.\r\n     * This can be used for errors created by compileModule...\r\n     */\r\n    getComponentFromError(error: Error): Type<any> | null;\r\n}\r\n\r\n/**\r\n * A factory for creating a Compiler\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class ɵTestingCompilerFactory {\r\n    abstract createTestingCompiler(options?: CompilerOptions[]): ɵTestingCompiler;\r\n}\r\n\r\nexport { }\r\n"]}