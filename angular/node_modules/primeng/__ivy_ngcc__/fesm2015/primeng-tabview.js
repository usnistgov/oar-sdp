import { EventEmitter, Input, Output, Component, ViewContainerRef, ChangeDetectorRef, ContentChildren, ElementRef, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TooltipModule } from 'primeng/tooltip';
import { PrimeTemplate, SharedModule } from 'primeng/api';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'primeng/tooltip';

const _c0 = ["p-tabViewNav", ""];
function TabViewNav_ng_template_0_li_0_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵproperty("ngClass", tab_r1.leftIcon);
} }
function TabViewNav_ng_template_0_li_0_ng_container_2_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵproperty("ngClass", tab_r1.rightIcon);
} }
function TabViewNav_ng_template_0_li_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabViewNav_ng_template_0_li_0_ng_container_2_span_1_Template, 1, 1, "span", 6);
    ɵngcc0.ɵɵelementStart(2, "span", 7);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TabViewNav_ng_template_0_li_0_ng_container_2_span_4_Template, 1, 1, "span", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.leftIcon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.header);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.rightIcon);
} }
function TabViewNav_ng_template_0_li_0_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabViewNav_ng_template_0_li_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabViewNav_ng_template_0_li_0_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r1.headerTemplate);
} }
function TabViewNav_ng_template_0_li_0_span_4_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵlistener("click", function TabViewNav_ng_template_0_li_0_span_4_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.clickClose($event, tab_r1); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c1 = function (a0, a1) { return { "ui-tabview-selected ui-state-active": a0, "ui-state-disabled": a1 }; };
function TabViewNav_ng_template_0_li_0_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 2);
    ɵngcc0.ɵɵlistener("click", function TabViewNav_ng_template_0_li_0_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.clickTab($event, tab_r1); })("keydown.enter", function TabViewNav_ng_template_0_li_0_Template_li_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.clickTab($event, tab_r1); });
    ɵngcc0.ɵɵelementStart(1, "a", 3);
    ɵngcc0.ɵɵtemplate(2, TabViewNav_ng_template_0_li_0_ng_container_2_Template, 5, 3, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(3, TabViewNav_ng_template_0_li_0_ng_container_3_Template, 2, 1, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TabViewNav_ng_template_0_li_0_span_4_Template, 1, 0, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r2.getDefaultHeaderClass(tab_r1));
    ɵngcc0.ɵɵproperty("ngStyle", tab_r1.headerStyle)("ngClass", ɵngcc0.ɵɵpureFunction2(16, _c1, tab_r1.selected, tab_r1.disabled));
    ɵngcc0.ɵɵattribute("tabindex", tab_r1.disabled ? 0 - 1 : 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("pTooltip", tab_r1.tooltip)("tooltipPosition", tab_r1.tooltipPosition)("positionStyle", tab_r1.tooltipPositionStyle)("tooltipStyleClass", tab_r1.tooltipStyleClass);
    ɵngcc0.ɵɵattribute("id", tab_r1.id + "-label")("aria-selected", tab_r1.selected)("aria-controls", tab_r1.id)("aria-selected", tab_r1.selected);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !tab_r1.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.closable);
} }
function TabViewNav_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabViewNav_ng_template_0_li_0_Template, 5, 19, "li", 1);
} if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", !tab_r1.closed);
} }
function TabPanel_div_0_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabPanel_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabPanel_div_0_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.contentTemplate);
} }
const _c2 = function (a0) { return { "ui-helper-hidden": a0 }; };
function TabPanel_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵtemplate(2, TabPanel_div_0_ng_container_2_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c2, !ctx_r0.selected));
    ɵngcc0.ɵɵattribute("id", ctx_r0.id)("aria-hidden", !ctx_r0.selected)("aria-labelledby", ctx_r0.id + "-label");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.contentTemplate && (ctx_r0.cache ? ctx_r0.loaded : ctx_r0.selected));
} }
const _c3 = ["*"];
function TabView_ul_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ul", 3);
    ɵngcc0.ɵɵlistener("onTabClick", function TabView_ul_1_Template_ul_onTabClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.open($event.originalEvent, $event.tab); })("onTabCloseClick", function TabView_ul_1_Template_ul_onTabCloseClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.close($event.originalEvent, $event.tab); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabs", ctx_r0.tabs)("orientation", ctx_r0.orientation);
} }
function TabView_ul_4_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ul", 3);
    ɵngcc0.ɵɵlistener("onTabClick", function TabView_ul_4_Template_ul_onTabClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.open($event.originalEvent, $event.tab); })("onTabCloseClick", function TabView_ul_4_Template_ul_onTabCloseClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.close($event.originalEvent, $event.tab); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabs", ctx_r1.tabs)("orientation", ctx_r1.orientation);
} }
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let idx = 0;
let TabViewNav = class TabViewNav {
    constructor() {
        this.orientation = 'top';
        this.onTabClick = new EventEmitter();
        this.onTabCloseClick = new EventEmitter();
    }
    getDefaultHeaderClass(tab) {
        let styleClass = 'ui-state-default ui-corner-' + this.orientation;
        if (tab.headerStyleClass) {
            styleClass = styleClass + " " + tab.headerStyleClass;
        }
        return styleClass;
    }
    clickTab(event, tab) {
        this.onTabClick.emit({
            originalEvent: event,
            tab: tab
        });
    }
    clickClose(event, tab) {
        this.onTabCloseClick.emit({
            originalEvent: event,
            tab: tab
        });
    }
};
TabViewNav.ɵfac = function TabViewNav_Factory(t) { return new (t || TabViewNav)(); };
TabViewNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabViewNav, selectors: [["", "p-tabViewNav", ""]], hostVars: 10, hostBindings: function TabViewNav_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ui-tabview-nav", true)("ui-helper-reset", true)("ui-helper-clearfix", true)("ui-widget-header", true)("ui-corner-all", true);
    } }, inputs: { orientation: "orientation", tabs: "tabs" }, outputs: { onTabClick: "onTabClick", onTabCloseClick: "onTabCloseClick" }, attrs: _c0, decls: 1, vars: 1, consts: [["ngFor", "", 3, "ngForOf"], ["role", "presentation", "tabindex", "0", 3, "class", "ngStyle", "ngClass", "click", "keydown.enter", 4, "ngIf"], ["role", "presentation", "tabindex", "0", 3, "ngStyle", "ngClass", "click", "keydown.enter"], ["role", "tab", 3, "pTooltip", "tooltipPosition", "positionStyle", "tooltipStyleClass"], [4, "ngIf"], ["class", "ui-tabview-close pi pi-times", 3, "click", 4, "ngIf"], ["class", "ui-tabview-left-icon", 3, "ngClass", 4, "ngIf"], [1, "ui-tabview-title"], ["class", "ui-tabview-right-icon", 3, "ngClass", 4, "ngIf"], [1, "ui-tabview-left-icon", 3, "ngClass"], [1, "ui-tabview-right-icon", 3, "ngClass"], [4, "ngTemplateOutlet"], [1, "ui-tabview-close", "pi", "pi-times", 3, "click"]], template: function TabViewNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TabViewNav_ng_template_0_Template, 1, 1, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgClass, ɵngcc2.Tooltip, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    Input()
], TabViewNav.prototype, "tabs", void 0);
__decorate([
    Input()
], TabViewNav.prototype, "orientation", void 0);
__decorate([
    Output()
], TabViewNav.prototype, "onTabClick", void 0);
__decorate([
    Output()
], TabViewNav.prototype, "onTabCloseClick", void 0);
let TabPanel = class TabPanel {
    constructor(viewContainer, cd) {
        this.viewContainer = viewContainer;
        this.cd = cd;
        this.cache = true;
        this.tooltipPosition = 'top';
        this.tooltipPositionStyle = 'absolute';
        this.id = `ui-tabpanel-${idx++}`;
    }
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            switch (item.getType()) {
                case 'header':
                    this.headerTemplate = item.template;
                    break;
                case 'content':
                    this.contentTemplate = item.template;
                    break;
                default:
                    this.contentTemplate = item.template;
                    break;
            }
        });
    }
    get selected() {
        return this._selected;
    }
    set selected(val) {
        this._selected = val;
        if (!this.loaded) {
            this.cd.detectChanges();
        }
        this.loaded = true;
    }
    ngOnDestroy() {
        this.view = null;
    }
};
TabPanel.ɵfac = function TabPanel_Factory(t) { return new (t || TabPanel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TabPanel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabPanel, selectors: [["p-tabPanel"]], contentQueries: function TabPanel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PrimeTemplate, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templates = _t);
    } }, inputs: { cache: "cache", tooltipPosition: "tooltipPosition", tooltipPositionStyle: "tooltipPositionStyle", selected: "selected", header: "header", disabled: "disabled", closable: "closable", headerStyle: "headerStyle", headerStyleClass: "headerStyleClass", leftIcon: "leftIcon", rightIcon: "rightIcon", tooltip: "tooltip", tooltipStyleClass: "tooltipStyleClass" }, ngContentSelectors: _c3, decls: 1, vars: 1, consts: [["class", "ui-tabview-panel ui-widget-content", "role", "tabpanel", 3, "ngClass", 4, "ngIf"], ["role", "tabpanel", 1, "ui-tabview-panel", "ui-widget-content", 3, "ngClass"], [4, "ngIf"], [4, "ngTemplateOutlet"]], template: function TabPanel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TabPanel_div_0_Template, 3, 7, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.closed);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
TabPanel.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], TabPanel.prototype, "header", void 0);
__decorate([
    Input()
], TabPanel.prototype, "disabled", void 0);
__decorate([
    Input()
], TabPanel.prototype, "closable", void 0);
__decorate([
    Input()
], TabPanel.prototype, "headerStyle", void 0);
__decorate([
    Input()
], TabPanel.prototype, "headerStyleClass", void 0);
__decorate([
    Input()
], TabPanel.prototype, "leftIcon", void 0);
__decorate([
    Input()
], TabPanel.prototype, "rightIcon", void 0);
__decorate([
    Input()
], TabPanel.prototype, "cache", void 0);
__decorate([
    Input()
], TabPanel.prototype, "tooltip", void 0);
__decorate([
    Input()
], TabPanel.prototype, "tooltipPosition", void 0);
__decorate([
    Input()
], TabPanel.prototype, "tooltipPositionStyle", void 0);
__decorate([
    Input()
], TabPanel.prototype, "tooltipStyleClass", void 0);
__decorate([
    ContentChildren(PrimeTemplate)
], TabPanel.prototype, "templates", void 0);
__decorate([
    Input()
], TabPanel.prototype, "selected", null);
let TabView = class TabView {
    constructor(el) {
        this.el = el;
        this.orientation = 'top';
        this.onChange = new EventEmitter();
        this.onClose = new EventEmitter();
        this.activeIndexChange = new EventEmitter();
    }
    ngAfterContentInit() {
        this.initTabs();
        this.tabPanels.changes.subscribe(_ => {
            this.initTabs();
        });
    }
    initTabs() {
        this.tabs = this.tabPanels.toArray();
        let selectedTab = this.findSelectedTab();
        if (!selectedTab && this.tabs.length) {
            if (this.activeIndex != null && this.tabs.length > this.activeIndex)
                this.tabs[this.activeIndex].selected = true;
            else
                this.tabs[0].selected = true;
        }
    }
    open(event, tab) {
        if (tab.disabled) {
            if (event) {
                event.preventDefault();
            }
            return;
        }
        if (!tab.selected) {
            let selectedTab = this.findSelectedTab();
            if (selectedTab) {
                selectedTab.selected = false;
            }
            tab.selected = true;
            let selectedTabIndex = this.findTabIndex(tab);
            this.preventActiveIndexPropagation = true;
            this.activeIndexChange.emit(selectedTabIndex);
            this.onChange.emit({ originalEvent: event, index: selectedTabIndex });
        }
        if (event) {
            event.preventDefault();
        }
    }
    close(event, tab) {
        if (this.controlClose) {
            this.onClose.emit({
                originalEvent: event,
                index: this.findTabIndex(tab),
                close: () => {
                    this.closeTab(tab);
                }
            });
        }
        else {
            this.closeTab(tab);
            this.onClose.emit({
                originalEvent: event,
                index: this.findTabIndex(tab)
            });
        }
        event.stopPropagation();
    }
    closeTab(tab) {
        if (tab.disabled) {
            return;
        }
        if (tab.selected) {
            tab.selected = false;
            for (let i = 0; i < this.tabs.length; i++) {
                let tabPanel = this.tabs[i];
                if (!tabPanel.closed && !tab.disabled) {
                    tabPanel.selected = true;
                    break;
                }
            }
        }
        tab.closed = true;
    }
    findSelectedTab() {
        for (let i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].selected) {
                return this.tabs[i];
            }
        }
        return null;
    }
    findTabIndex(tab) {
        let index = -1;
        for (let i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i] == tab) {
                index = i;
                break;
            }
        }
        return index;
    }
    getBlockableElement() {
        return this.el.nativeElement.children[0];
    }
    get activeIndex() {
        return this._activeIndex;
    }
    set activeIndex(val) {
        this._activeIndex = val;
        if (this.preventActiveIndexPropagation) {
            this.preventActiveIndexPropagation = false;
            return;
        }
        if (this.tabs && this.tabs.length && this._activeIndex != null && this.tabs.length > this._activeIndex) {
            this.findSelectedTab().selected = false;
            this.tabs[this._activeIndex].selected = true;
        }
    }
};
TabView.ɵfac = function TabView_Factory(t) { return new (t || TabView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TabView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabView, selectors: [["p-tabView"]], contentQueries: function TabView_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabPanel, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabPanels = _t);
    } }, inputs: { orientation: "orientation", activeIndex: "activeIndex", style: "style", styleClass: "styleClass", controlClose: "controlClose" }, outputs: { onChange: "onChange", onClose: "onClose", activeIndexChange: "activeIndexChange" }, ngContentSelectors: _c3, decls: 5, vars: 6, consts: [[3, "ngClass", "ngStyle"], ["p-tabViewNav", "", "role", "tablist", 3, "tabs", "orientation", "onTabClick", "onTabCloseClick", 4, "ngIf"], [1, "ui-tabview-panels"], ["p-tabViewNav", "", "role", "tablist", 3, "tabs", "orientation", "onTabClick", "onTabCloseClick"]], template: function TabView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, TabView_ul_1_Template, 1, 2, "ul", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, TabView_ul_4_Template, 1, 2, "ul", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClass);
        ɵngcc0.ɵɵproperty("ngClass", "ui-tabview ui-widget ui-widget-content ui-corner-all ui-tabview-" + ctx.orientation)("ngStyle", ctx.style);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.orientation != "bottom");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.orientation == "bottom");
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgStyle, ɵngcc1.NgIf, TabViewNav], encapsulation: 2 });
TabView.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], TabView.prototype, "orientation", void 0);
__decorate([
    Input()
], TabView.prototype, "style", void 0);
__decorate([
    Input()
], TabView.prototype, "styleClass", void 0);
__decorate([
    Input()
], TabView.prototype, "controlClose", void 0);
__decorate([
    ContentChildren(TabPanel)
], TabView.prototype, "tabPanels", void 0);
__decorate([
    Output()
], TabView.prototype, "onChange", void 0);
__decorate([
    Output()
], TabView.prototype, "onClose", void 0);
__decorate([
    Output()
], TabView.prototype, "activeIndexChange", void 0);
__decorate([
    Input()
], TabView.prototype, "activeIndex", null);
let TabViewModule = class TabViewModule {
};
TabViewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabViewModule });
TabViewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TabViewModule_Factory(t) { return new (t || TabViewModule)(); }, imports: [[CommonModule, SharedModule, TooltipModule],
        SharedModule] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabViewNav, [{
        type: Component,
        args: [{
                selector: '[p-tabViewNav]',
                host: {
                    '[class.ui-tabview-nav]': 'true',
                    '[class.ui-helper-reset]': 'true',
                    '[class.ui-helper-clearfix]': 'true',
                    '[class.ui-widget-header]': 'true',
                    '[class.ui-corner-all]': 'true'
                },
                template: `
        <ng-template ngFor let-tab [ngForOf]="tabs">
            <li [class]="getDefaultHeaderClass(tab)" [ngStyle]="tab.headerStyle" role="presentation" [attr.tabindex]="tab.disabled ? -1 : 0"
                [ngClass]="{'ui-tabview-selected ui-state-active': tab.selected, 'ui-state-disabled': tab.disabled}"
                (click)="clickTab($event,tab)" *ngIf="!tab.closed" tabindex="0" (keydown.enter)="clickTab($event,tab)">
                <a [attr.id]="tab.id + '-label'" role="tab" [attr.aria-selected]="tab.selected" [attr.aria-controls]="tab.id" [pTooltip]="tab.tooltip" [tooltipPosition]="tab.tooltipPosition"
                    [attr.aria-selected]="tab.selected" [positionStyle]="tab.tooltipPositionStyle" [tooltipStyleClass]="tab.tooltipStyleClass">
                    <ng-container *ngIf="!tab.headerTemplate" >
                        <span class="ui-tabview-left-icon" [ngClass]="tab.leftIcon" *ngIf="tab.leftIcon"></span>
                        <span class="ui-tabview-title">{{tab.header}}</span>
                        <span class="ui-tabview-right-icon" [ngClass]="tab.rightIcon" *ngIf="tab.rightIcon"></span>
                    </ng-container>
                    <ng-container *ngIf="tab.headerTemplate">
                        <ng-container *ngTemplateOutlet="tab.headerTemplate"></ng-container>
                    </ng-container>
                </a>
                <span *ngIf="tab.closable" class="ui-tabview-close pi pi-times" (click)="clickClose($event,tab)"></span>
            </li>
        </ng-template>
    `
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], onTabClick: [{
            type: Output
        }], onTabCloseClick: [{
            type: Output
        }], tabs: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabPanel, [{
        type: Component,
        args: [{
                selector: 'p-tabPanel',
                template: `
        <div [attr.id]="id" class="ui-tabview-panel ui-widget-content" [ngClass]="{'ui-helper-hidden': !selected}"
            role="tabpanel" [attr.aria-hidden]="!selected" [attr.aria-labelledby]="id + '-label'" *ngIf="!closed">
            <ng-content></ng-content>
            <ng-container *ngIf="contentTemplate && (cache ? loaded : selected)">
                <ng-container *ngTemplateOutlet="contentTemplate"></ng-container>
            </ng-container>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cache: [{
            type: Input
        }], tooltipPosition: [{
            type: Input
        }], tooltipPositionStyle: [{
            type: Input
        }], selected: [{
            type: Input
        }], header: [{
            type: Input
        }], disabled: [{
            type: Input
        }], closable: [{
            type: Input
        }], headerStyle: [{
            type: Input
        }], headerStyleClass: [{
            type: Input
        }], leftIcon: [{
            type: Input
        }], rightIcon: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], tooltipStyleClass: [{
            type: Input
        }], templates: [{
            type: ContentChildren,
            args: [PrimeTemplate]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabView, [{
        type: Component,
        args: [{
                selector: 'p-tabView',
                template: `
        <div [ngClass]="'ui-tabview ui-widget ui-widget-content ui-corner-all ui-tabview-' + orientation" [ngStyle]="style" [class]="styleClass">
            <ul p-tabViewNav role="tablist" *ngIf="orientation!='bottom'" [tabs]="tabs" [orientation]="orientation"
                (onTabClick)="open($event.originalEvent, $event.tab)" (onTabCloseClick)="close($event.originalEvent, $event.tab)"></ul>
            <div class="ui-tabview-panels">
                <ng-content></ng-content>
            </div>
            <ul p-tabViewNav role="tablist" *ngIf="orientation=='bottom'" [tabs]="tabs" [orientation]="orientation"
                (onTabClick)="open($event.originalEvent, $event.tab)" (onTabCloseClick)="close($event.originalEvent, $event.tab)"></ul>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.Default
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { orientation: [{
            type: Input
        }], onChange: [{
            type: Output
        }], onClose: [{
            type: Output
        }], activeIndexChange: [{
            type: Output
        }], activeIndex: [{
            type: Input
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], controlClose: [{
            type: Input
        }], tabPanels: [{
            type: ContentChildren,
            args: [TabPanel]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabViewModule, { declarations: function () { return [TabView,
        TabPanel,
        TabViewNav]; }, imports: function () { return [CommonModule, SharedModule, TooltipModule]; }, exports: function () { return [TabView,
        TabPanel,
        TabViewNav,
        SharedModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabViewModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, SharedModule, TooltipModule],
                exports: [TabView, TabPanel, TabViewNav, SharedModule],
                declarations: [TabView, TabPanel, TabViewNav]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TabPanel, TabView, TabViewModule, TabViewNav };

//# sourceMappingURL=primeng-tabview.js.map